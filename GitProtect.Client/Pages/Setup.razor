@page "/setup"
@rendermode InteractiveWebAssembly
@inject NavigationManager Nav
@inject ApiClient Api

<PageTitle>Setup</PageTitle>

<Card>
    <CardHeader>
        <CardTitle>Setup GitProtect</CardTitle>
        <CardDescription>Connect a provider, then verify S3 storage.</CardDescription>
    </CardHeader>
</Card>

<Separator />

@if (!string.IsNullOrWhiteSpace(error))
{
    <Badge Variant="BadgeVariant.Destructive">@error</Badge>
}

@if (step == 1)
{
    <Card>
        <CardHeader><CardTitle>Provider</CardTitle></CardHeader>
        <CardContent>
            <p>Provider</p>
            <select @bind="selectedProvider" @bind:after="OnProviderChanged">
                <option value="@ProviderType.GitHub">GitHub</option>
                <option value="@ProviderType.GitLab">GitLab</option>
                <option value="@ProviderType.Forgejo">Forgejo</option>
            </select>
            <p>Instance URL</p><Input @bind-Value="baseUrl" />
            <p>Username</p><Input @bind-Value="username" />
            <p>API Key</p><Input @bind-Value="apiKey" Type="InputType.Password" />
            <div><Button @onclick="ContinueToStorage" Disabled="@isBusy">Continue to Storage</Button></div>
        </CardContent>
    </Card>
}
else
{
    <Card>
        <CardHeader><CardTitle>Storage</CardTitle></CardHeader>
        <CardContent>
            <p>Endpoint</p><Input @bind-Value="s3Endpoint" />
            <p>Region</p><Input @bind-Value="s3Region" />
            <p>Bucket</p><Input @bind-Value="s3Bucket" />
            <p>Access Key</p><Input @bind-Value="s3AccessKey" />
            <p>Secret Key</p><Input @bind-Value="s3SecretKey" Type="InputType.Password" />
            <p>Path Style</p><Checkbox @bind-Checked="s3UsePathStyle" />
            <div>
                <Button Variant="ButtonVariant.Secondary" @onclick="() => step = 1" Disabled="@isBusy">Back</Button>
                <Button @onclick="SaveStorage" Disabled="@isBusy">Verify & Save</Button>
            </div>
        </CardContent>
    </Card>
}

@code {
    private int step = 1;
    private bool isBusy;
    private string? error;

    private ProviderType selectedProvider = ProviderType.GitHub;
    private string baseUrl = "https://github.com";
    private string username = string.Empty;
    private string apiKey = string.Empty;

    private string s3Endpoint = string.Empty;
    private string s3Region = string.Empty;
    private string s3Bucket = string.Empty;
    private string s3AccessKey = string.Empty;
    private string s3SecretKey = string.Empty;
    private bool s3UsePathStyle;

    private async Task ContinueToStorage()
    {
        error = null;
        isBusy = true;
        try
        {
            var result = await Api.SaveProviderAsync(selectedProvider, new ProviderUpsertRequest(baseUrl, username, apiKey));
            if (!result.Success || result.Data is null)
            {
                error = result.Error ?? "Provider validation failed. Please verify your URL and API key.";
                return;
            }

            step = 2;
        }
        finally
        {
            isBusy = false;
        }
    }

    private async Task SaveStorage()
    {
        error = null;
        isBusy = true;
        try
        {
            var result = await Api.SaveStorageAsync(new S3UpsertRequest(s3Endpoint, s3Region, s3Bucket, s3AccessKey, s3SecretKey, s3UsePathStyle));
            if (!result.Success || result.Data is null)
            {
                error = result.Error ?? "Storage validation failed. Please check your S3 credentials.";
                return;
            }

            Nav.NavigateTo($"/backups/{selectedProvider.ToString().ToLowerInvariant()}");
        }
        finally
        {
            isBusy = false;
        }
    }

    private Task OnProviderChanged()
    {
        baseUrl = selectedProvider switch
        {
            ProviderType.GitHub => "https://github.com",
            ProviderType.GitLab => "https://gitlab.com",
            ProviderType.Forgejo => "https://codeberg.org",
            _ => baseUrl
        };

        return Task.CompletedTask;
    }
}
