@page "/backups/forgejo"
@rendermode InteractiveWebAssembly
@implements IAsyncDisposable
@inject ApiClient Api

<PageTitle>Forgejo Backups</PageTitle>

<MudStack Spacing="3">
    <MudPaper Elevation="1" Class="pa-4">
        <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center" Wrap="Wrap.Wrap" Spacing="2">
            <MudStack Spacing="0">
                <MudText Typo="Typo.h4">Forgejo Backups</MudText>
                <MudText Typo="Typo.body2" Color="Color.Secondary">Repository backups for self-hosted Forgejo instances.</MudText>
            </MudStack>

            <MudStack Row="true" Spacing="1">
                <MudButton Variant="Variant.Outlined"
                           Color="Color.Primary"
                           StartIcon="@Icons.Material.Filled.Sync"
                           OnClick="SyncRepos"
                           Disabled="@(isSyncing || isLoading)">
                    Sync Repos
                </MudButton>
                <MudButton Variant="Variant.Filled"
                           Color="Color.Primary"
                           StartIcon="@Icons.Material.Filled.PlayArrow"
                           OnClick="RunBackup"
                           Disabled="@(isProviderBackupRequested || IsProviderBackupRunning || isLoading)">
                    Run Backup
                </MudButton>
            </MudStack>
        </MudStack>
    </MudPaper>

    @if (isLoading)
    {
        <MudAlert Severity="Severity.Info" Variant="Variant.Outlined">Loading repositories...</MudAlert>
    }
    else if (!string.IsNullOrWhiteSpace(error))
    {
        <MudAlert Severity="Severity.Error" Variant="Variant.Outlined">@error</MudAlert>
    }
    else if (provider is null || !provider.IsVerified)
    {
        <MudAlert Severity="Severity.Warning" Variant="Variant.Outlined">Connect Forgejo in Setup or Settings to view repositories.</MudAlert>
    }
    else if (repositories.Count == 0)
    {
        <MudAlert Severity="Severity.Info" Variant="Variant.Outlined">No repositories found. Sync to pull your list.</MudAlert>
    }
    else
    {
        <MudPaper Elevation="1" Class="pa-2">
            <MudTable Items="repositories" Dense="true" Hover="true" Bordered="true">
                <HeaderContent>
                    <MudTh>Repository</MudTh>
                    <MudTh>Status</MudTh>
                    <MudTh>Last Backup</MudTh>
                    <MudTh>Size</MudTh>
                    <MudTh>Actions</MudTh>
                </HeaderContent>
                <RowTemplate>
                    <MudTd DataLabel="Repository">@context.FullName</MudTd>
                    <MudTd DataLabel="Status">
                        @if (context.Status == BackupStatus.Failed)
                        {
                            <MudStack Spacing="1">
                                <MudChip T="string" Color="Color.Error" Variant="Variant.Filled" Size="Size.Small">Failed</MudChip>
                                <MudText Typo="Typo.caption">@(string.IsNullOrWhiteSpace(context.LastBackupMessage) ? "No details" : context.LastBackupMessage)</MudText>
                            </MudStack>
                        }
                        else
                        {
                            <MudChip T="string" Color="@GetStatusColor(context.Status)" Variant="Variant.Filled" Size="Size.Small">@GetStatusLabel(context.Status)</MudChip>
                        }
                    </MudTd>
                    <MudTd DataLabel="Last Backup">@(context.LastBackupAt?.ToLocalTime().ToString("g") ?? "Never")</MudTd>
                    <MudTd DataLabel="Size">@FormatBytes(context.LastBackupSizeBytes)</MudTd>
                    <MudTd DataLabel="Actions">
                        <MudButton Variant="Variant.Outlined"
                                   Color="Color.Primary"
                                   StartIcon="@Icons.Material.Filled.Backup"
                                   OnClick='() => RunRepoBackup(context.Id)'
                                   Disabled="@(IsRepoBackupDisabled(context.Id))">
                            Backup
                        </MudButton>
                    </MudTd>
                </RowTemplate>
            </MudTable>
        </MudPaper>
    }
</MudStack>

@code {
    private ProviderStatusDto? provider;
    private List<RepositoryDto> repositories = new();
    private List<BackupTaskDto> tasks = new();
    private bool isLoading = true;
    private bool isRefreshing;
    private bool isSyncing;
    private bool isProviderBackupRequested;
    private readonly HashSet<int> repoBackupRequests = new();
    private CancellationTokenSource? refreshCts;
    private PeriodicTimer? refreshTimer;
    private readonly TimeSpan refreshInterval = TimeSpan.FromSeconds(5);
    private string? error;

    private ProviderType Provider => ProviderType.Forgejo;

    protected override async Task OnInitializedAsync()
    {
        await LoadAsync(showLoading: true);
        StartAutoRefresh();
    }

    private void StartAutoRefresh()
    {
        refreshCts = new CancellationTokenSource();
        refreshTimer = new PeriodicTimer(refreshInterval);
        _ = RefreshLoopAsync(refreshCts.Token);
    }

    private async Task RefreshLoopAsync(CancellationToken cancellationToken)
    {
        if (refreshTimer is null)
        {
            return;
        }

        try
        {
            while (await refreshTimer.WaitForNextTickAsync(cancellationToken))
            {
                await LoadAsync(showLoading: false, cancellationToken);
                await InvokeAsync(StateHasChanged);
            }
        }
        catch (OperationCanceledException)
        {
        }
    }

    private async Task LoadAsync(bool showLoading, CancellationToken cancellationToken = default)
    {
        if (isRefreshing)
        {
            return;
        }

        isRefreshing = true;
        if (showLoading)
        {
            isLoading = true;
            error = null;
        }

        try
        {
            var providers = await Api.GetProvidersAsync(cancellationToken);
            provider = providers.FirstOrDefault(p => p.Provider == Provider);
            tasks = await Api.GetTasksAsync(limit: 200, cancellationToken);
            if (provider?.IsVerified == true)
            {
                repositories = await Api.GetReposAsync(Provider, cancellationToken);
            }
            else
            {
                repositories = new();
            }

            error = null;
        }
        catch (Exception ex)
        {
            error = ex.Message;
        }
        finally
        {
            if (showLoading)
            {
                isLoading = false;
            }

            isRefreshing = false;
        }
    }

    private async Task SyncRepos()
    {
        if (isSyncing)
        {
            return;
        }

        isSyncing = true;
        try
        {
            await Api.SyncReposAsync(Provider);
            await LoadAsync(showLoading: false);
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            isSyncing = false;
        }
    }

    private async Task RunBackup()
    {
        if (IsProviderBackupRunning || isProviderBackupRequested)
        {
            return;
        }

        isProviderBackupRequested = true;
        try
        {
            await Api.RunBackupAsync(Provider);
            await LoadAsync(showLoading: false);
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            isProviderBackupRequested = false;
        }
    }

    private async Task RunRepoBackup(int repoId)
    {
        if (IsRepoBackupDisabled(repoId))
        {
            return;
        }

        repoBackupRequests.Add(repoId);
        try
        {
            await Api.RunRepositoryBackupAsync(Provider, repoId);
            await LoadAsync(showLoading: false);
            await InvokeAsync(StateHasChanged);
        }
        finally
        {
            repoBackupRequests.Remove(repoId);
        }
    }

    private static string FormatBytes(long? bytes)
    {
        if (!bytes.HasValue)
        {
            return "-";
        }

        double size = bytes.Value;
        string[] units = ["B", "KB", "MB", "GB", "TB"];
        var unitIndex = 0;
        while (size >= 1024 && unitIndex < units.Length - 1)
        {
            size /= 1024;
            unitIndex++;
        }

        return $"{size:0.#} {units[unitIndex]}";
    }

    private static string GetStatusLabel(BackupStatus status) => status switch
    {
        BackupStatus.Success => "Healthy",
        BackupStatus.Running => "Running",
        BackupStatus.Failed => "Failed",
        _ => "Never"
    };

    private static Color GetStatusColor(BackupStatus status) => status switch
    {
        BackupStatus.Success => Color.Success,
        BackupStatus.Running => Color.Info,
        BackupStatus.Failed => Color.Error,
        _ => Color.Default
    };

    private bool IsProviderBackupRunning => tasks.Any(task =>
        task.TaskType == BackupTaskType.Backup
        && task.Provider == Provider
        && task.RepositoryId is null
        && IsTaskActive(task.Status));

    private bool IsRepoBackupDisabled(int repoId)
    {
        return isLoading
            || repoBackupRequests.Contains(repoId)
            || IsProviderBackupRunning
            || tasks.Any(task =>
                task.TaskType == BackupTaskType.Backup
                && task.Provider == Provider
                && task.RepositoryId == repoId
                && IsTaskActive(task.Status));
    }

    private static bool IsTaskActive(BackupTaskStatus status)
        => status is BackupTaskStatus.Pending or BackupTaskStatus.Running;

    public ValueTask DisposeAsync()
    {
        refreshCts?.Cancel();
        refreshTimer?.Dispose();
        refreshCts?.Dispose();
        return ValueTask.CompletedTask;
    }
}
